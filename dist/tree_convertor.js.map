{"version":3,"sources":["../src/tree_convertor.js"],"names":["getTreeStructureData","data","obj","children","name","type","parent","distinctSites","findDisctinct","i","length","category","ob","info","push","getReasons","reasons","filter","d","category_id","parent_reason_id","reason_id","distinctReasons","k","reason","collapsed","addReasons","node","childReasons","child","arrObj","s","areaArr","reduce","arr","record","Array","from","Set"],"mappings":";;;;;AAAE;;;;;AAKO,WAASA,oBAAT,CAA8BC,IAA9B,EAAmC;AACxC;AACA,QAAIC,MAAM;AACRC,gBAAU,EADF;AAERC,YAAM,aAFE;AAGRC,YAAM,MAHE;AAIRC,cAAQ;;AAGV;AAPU,KAAV,CAQA,IAAMC,gBAAgBC,cAAcP,IAAd,EAAoB,UAApB,CAAtB;;AAEA,SAAK,IAAIQ,IAAI,CAAb,EAAgBA,IAAIF,cAAcG,MAAlC,EAA0CD,GAA1C,EAA+C;AAC7C,UAAME,WAAWJ,cAAcE,CAAd,CAAjB;AACA,UAAIG,KAAK;AACPR,cAAMO,QADC;AAEPR,kBAAU,EAFH;AAGP;AACAE,cAAM,UAJC;AAKPC,gBAAQJ,IAAIE,IALL;AAMPS,cAAK;AACDF,oBAAUA;AADT;AANE,OAAT;AAUAT,UAAIC,QAAJ,CAAaW,IAAb,CAAkBF,EAAlB;AACD;;AAED,WAAOG,WAAWb,GAAX,EAAgBD,IAAhB,CAAP;AACD;;AAED;;;;;;;kCA9BgBD,oB;;AAoChB,WAASe,UAAT,CAAoBb,GAApB,EAAyBD,IAAzB,EAA8B;AAAA,+BAEnBQ,CAFmB;AAG1B,UAAME,WAAWT,IAAIC,QAAJ,CAAaM,CAAb,CAAjB;AACA;AACA,UAAMO,UAAUf,KAAKgB,MAAL,CAAY;AAAA,eAAKC,EAAEC,WAAF,KAAkB,IAAlB,IAA0BD,EAAEC,WAAF,KAAkBR,SAASP,IAArD,IAA6Dc,EAAEE,gBAAF,KAAuB,IAApF,IAA4FF,EAAEG,SAAF,KAAgB,IAAjH;AAAA,OAAZ,CAAhB;AACA;AACA,UAAMC,kBAAkBd,cAAcQ,OAAd,EAAuB,QAAvB,CAAxB;AACA;AACA,WAAK,IAAIO,IAAI,CAAb,EAAgBA,IAAID,gBAAgBZ,MAApC,EAA4Ca,GAA5C,EAAiD;AAC/C,YAAMC,SAASF,gBAAgBC,CAAhB,CAAf;AACA,YAAIX,KAAK;AACPR,gBAAMoB,MADC;AAEPrB,oBAAU,EAFH;AAGPsB,qBAAW,KAHJ;AAIPpB,gBAAM,eAJC;AAKPC,kBAAQJ,IAAIC,QAAJ,CAAaM,CAAb,EAAgBL,IALjB;AAMPS,gBAAM;AACJF,sBAAUA,SAASP,IADf;AAEJoB,oBAAQA;AAFJ;AANC,SAAT;AAWAZ,aAAKc,WAAWd,EAAX,EAAeD,QAAf,EAAyBV,IAAzB,CAAL;AACAC,YAAIC,QAAJ,CAAaM,CAAb,EAAgBN,QAAhB,CAAyBW,IAAzB,CAA8BF,EAA9B;AACD;AAxByB;;AAC5B;AACA,SAAK,IAAIH,IAAI,CAAb,EAAgBA,IAAIP,IAAIC,QAAJ,CAAaO,MAAjC,EAAyCD,GAAzC,EAA8C;AAAA,YAArCA,CAAqC;AAuB7C;AACD,WAAOP,GAAP;AACD;;AAED;;;;;;;AAOA,WAASwB,UAAT,CAAoBC,IAApB,EAA0BhB,QAA1B,EAAoCV,IAApC,EAAyC;AACvC;AACA,QAAI2B,eAAe3B,KAAKgB,MAAL,CAAY;AAAA,aAAKC,EAAEG,SAAF,KAAgB,IAAhB,IAAwBH,EAAEE,gBAAF,KAAuB,IAA/C,IAAuDF,EAAEC,WAAF,KAAkBR,SAASP,IAAlF,IAA0Fc,EAAEE,gBAAF,KAAuBO,KAAKvB,IAA3H;AAAA,KAAZ,CAAnB;AACA,QAAIwB,aAAalB,MAAb,GAAsB,CAA1B,EAA6B;AAC3B;AACA,UAAMY,mBAAkBd,cAAcoB,YAAd,EAA4B,QAA5B,CAAxB;AACA;AACA,WAAK,IAAInB,IAAI,CAAb,EAAgBA,IAAIa,iBAAgBZ,MAApC,EAA4CD,GAA5C,EAAiD;AAC/C,YAAMe,SAASF,iBAAgBb,CAAhB,CAAf;AACA;AACA,YAAIoB,QAAQ;AACVzB,gBAAMoB,MADI;AAEVrB,oBAAU,EAFA;AAGVsB,qBAAW,KAHD;AAIVpB,gBAAM,QAJI;AAKVC,kBAAQqB,KAAKvB,IALH;AAMVS,gBAAM;AACJF,sBAAUA,SAASP,IADf;AAEJoB,oBAAQA;AAFJ;AAKR;AAXY,SAAZ,CAYAK,QAAQH,WAAWG,KAAX,EAAkBlB,QAAlB,EAA4BV,IAA5B,CAAR;AACA;AACA0B,aAAKxB,QAAL,CAAcM,CAAd,IAAmBoB,KAAnB;AACD;AACF;;AAED;AACA,WAAOF,IAAP;AACD;;AAEC;;;;;;;AAOF,WAASnB,aAAT,CAAuBsB,MAAvB,EAA+BC,CAA/B,EAAiC;AAC/B,QAAMC,UAAUF,OAAOG,MAAP,CAAc,UAACC,GAAD,EAAMC,MAAN,EAAiB;AAC9C,UAAIJ,MAAM,UAAV,EAAsB;AACnBG,YAAIpB,IAAJ,CAASqB,OAAOhB,WAAhB;AACD,OAFF,MAEO,IAAIY,MAAM,QAAV,EAAmB;AACvBG,YAAIpB,IAAJ,CAASqB,OAAOd,SAAhB;AACD;AACD,aAAOa,GAAP;AACD,KAPe,EAOb,EAPa,CAAhB;AAQA,WAAOE,MAAMC,IAAN,CAAW,IAAIC,GAAJ,CAAQN,OAAR,CAAX,CAAP;AACD,G","file":"tree_convertor.js","sourcesContent":["  /**\n   * Expecting list of all data\n   * Then first make a root, and category\n   * @param {*} data \n   */\n  export function getTreeStructureData(data){\n    //root\n    let obj = {\n      children: [],\n      name: 'ReasonCodes',\n      type: 'Root',\n      parent: null\n    }\n\n    //take all sites out from an array of objects, find disctinct, and make those distinct values a new array of strings\n    const distinctSites = findDisctinct(data, 'category')\n    \n    for (let i = 0; i < distinctSites.length; i++) {\n      const category = distinctSites[i];\n      let ob = {\n        name: category,\n        children: [], \n        // collapsed: false,\n        type: 'Category', \n        parent: obj.name,\n        info:{\n            category: category\n        }\n      }\n      obj.children.push(ob)\n    }\n\n    return getReasons(obj, data)\n  }\n\n  /**\n   * Expecting the tree structed obj, and the list structured array of objects\n   * Add distinct areas to their matching sites\n   * @param {*} obj \n   * @param {*} data \n   */\n  function getReasons(obj, data){\n    //Under the mother root, for each sites\n    for (let i = 0; i < obj.children.length; i++) {\n      const category = obj.children[i];\n      //find areas that are under this site\n      const reasons = data.filter(d => d.category_id !== null && d.category_id === category.name && d.parent_reason_id === null && d.reason_id !== null)\n      //all areas to distinct areas\n      const distinctReasons = findDisctinct(reasons, 'reason')\n      //add each distinct area to this site\n      for (let k = 0; k < distinctReasons.length; k++) {\n        const reason = distinctReasons[k];\n        let ob = {\n          name: reason, \n          children: [], \n          collapsed: false,\n          type: 'Parent Reason', \n          parent: obj.children[i].name,\n          info: {\n            category: category.name,\n            reason: reason\n          }\n        }\n        ob = addReasons(ob, category, data)\n        obj.children[i].children.push(ob)\n      }\n    }\n    return obj\n  }\n\n  /**\n   * Expecting the current node, the current node's matching site, area, line and category, and the list data\n   * If the current node has child, add child to the current node, then call this method again and pass the child as the current node.\n   * @param {*} node \n   * @param {*} category \n   * @param {*} data \n   */\n  function addReasons(node, category, data){\n    //find the node's children\n    let childReasons = data.filter(d => d.reason_id !== null && d.parent_reason_id !== null && d.category_id === category.name && d.parent_reason_id === node.name)\n    if (childReasons.length > 0) {\n      //node's children to node's disctinct children\n      const distinctReasons = findDisctinct(childReasons, 'reason')\n      //for each children\n      for (let i = 0; i < distinctReasons.length; i++) {\n        const reason = distinctReasons[i];\n        //init this child\n        let child = {\n          name: reason,\n          children: [],\n          collapsed: false,\n          type: 'Reason',\n          parent: node.name,\n          info: {\n            category: category.name,\n            reason: reason\n          }\n        }\n        //add this child's children to this child before adding this child to this child's parent\n        child = addReasons(child, category, data)\n        //add this child to parent\n        node.children[i] = child\n      }\n    }\n    \n    //Ultramately return the levelOneReason\n    return node\n  }\n\n    /**\n   * Expecting an array of objects, and a string of keyword\n   * Based on different attributes keywords passed in\n   * Return an array of distinct and keyword-matching values of the array of objects\n   * @param {*} arrObj \n   * @param {*} s \n   */\n  function findDisctinct(arrObj, s){\n    const areaArr = arrObj.reduce((arr, record) => {\n     if (s === 'category') {\n        arr.push(record.category_id)\n      }else if (s === 'reason'){\n        arr.push(record.reason_id)\n      }\n      return arr\n    }, [])\n    return Array.from(new Set(areaArr))\n  }"]}